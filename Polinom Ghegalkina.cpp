//программа для решения полинома жегалкина
//на вход в файл TextFile1.txt пишется флаг для рандома
// если нужен рандом, то вводится 1,пробел,количесвто переменных
// если нет, то 0,пробел, количество переменных,пробел и сами переменные через пробел
//на выход в файле TextFile2.txt получаем таблицу истинности и функцию F вида F=a0+a1x1+a2x2+a3x3+a4x1x2+a5x1x3+a6x2x3+a7x1x2x3 для трех переменных где ""-умножение а "+"-xor
#include <iostream>
#include <cmath>
#include <vector>
#include <fstream>
#include <string>
#include <clocale>
#include <ctime>
#include <random>
using namespace std;
void Bin(vector<vector<int>>& F, int f, int xyz)//заполняем таблицу истинности по принципу 2^n/2 0 потом столько же едениц следующистолбик в два раза чаще
{//F-таблица истинности f количество строк в таблице ситинности xyz количество переменных
	int x = f, b;
	for (int i = 0; i < xyz; i++)
	{
		b = 0;//число которое мы записываем в таблицу
		x /= 2;//шаг заполнения
		for (int j = 0; j < f; j++)
		{
			if (j != 0 && j / x && j % x == 0)//условие того, что пора писать вместо 0 1 или вместо 1 0
			{
				if (b)b = 0;
				else b = 1;// меняем 0 на 1 и 1 на 0
			}
			F[j][i] = b;//записываем 0 и 1 в таблицу

		}

	}


}
int Xor(int x1 = 0, int  x2 = 0) // сложение по модулю 2 елси разные значит 1
{
	int x = x1;
	if (x == x2) x = 0; else x = 1;
	return x;
}
int And(int x1 = 1, int  x2 = 1)// логическое & для счета если хотя бы один не еденица то 0 (просто если или то достаточно первого условия, чтобы не проверять второе)
{
	int x = 1;
	if (x1 != 1 || 1 != x2) x = 0;
	return x;
}

//...
void finder_coef(int f, int& n, int& f1, vector<vector<int>> F, int xyz, vector<vector<int>>& b, int& k, int& k1, vector<vector<int>>& I)
{
	for (int z = 0; z < f; z++)//значит цикл по таблице вниз
	{
		f1 = 0;//для занчения функции
		k = 0;//счетчик для а(к)
		while (k != f) //пока не дощли до конца таблицы
		{

			n = 1;//для значения набора х1*х1*х3...
			for (int i1 = 0; i1 < xyz; i1++)//цикл по строке в таблице набора решений
			{//считаем произведение
				if (I[k][i1] != 0)
					n = And(F[z][i1], n);
			}
			if (b[k][0] == 1) //b[k][0] здесь хранится флаг нахождения переменной т.к.переменная м б и 0 и 1 и проверять не удобно
			{
				f1 = Xor(And(b[k][1], n), f1);
				k++;//добовляем в значение функции если коэффициент уже найден
			}
			else
			{
				if (n == 1)//если данное произведение переменных из z строки таблицы истинности равно 1 то здесь есть коэффициент который нужно искать дальше
				{
					b[k][0] = 1;//ищем его кстати методом подбора. в этой строчке меняем флаг дальше меняем переменную на 1 и добавляем в расчет функции
					b[k][1] = 1;
					k1 = k;//запоминаем индекс элемента, который подбираем
					f1 = Xor(And(b[k][1], n), f1);
					k++;
				}
				else k++;
			}
		}
		if (F[z][xyz] != f1) b[k1][1] = 0; //проверяем подходит ли значение коэффициента, если нет меняем

	}
}

//...
void spec_sort(int f, int xyz, vector<vector<int>>& I)
{//до этого мы сюда запихнули таблицу истинности, нобор строк которой соответствует набору строк таблицы наборов переменных из флагов
//собственно просто сортируем ее по количествупеременных в наборе
	vector <vector<int>>I1(f, vector<int>(xyz));
	int q;//счетчик числа переменных
	int k = 0;//счетчик отсортированных записей
	for (int i = 0; i <= xyz; i++)//цикл по количеству переменных
	{
		for (int z = f - 1; z >= 0; z--)//цикл по строкам для красоты с конца, чтобы потом переменные были по порядку
		{
			q = 0;
			for (int x = 0; x < xyz; x++)
				if (I[z][x] == 1)q++;//считаем число переменных
			if (q == i)
			{
				for (int x = 0; x < xyz; x++)
					I1[k][x] = I[z][x];//переносим азпись во временный вектор
				k++;
			}
		}
	}
	I = I1;

}
//...
void schet(int f, int xyz, vector<vector<int>> F, vector<vector<int>>& b)
{// f количество строк(коэффициентов) xyz количество переменных F таблица истинности b таблица коэффициентов
	Bin(F, f, xyz);//заполняем таблицу истинности

	int n = 1;
	int k = 0, k1 = 0;
	int f1 = 0;
	vector<vector<int>>I(f, vector<int>(xyz));//создание таблицы наборов переменных

	Bin(I, f, xyz); //заполняем массив наборами



	spec_sort(f, xyz, I);//сортируем массив по количеству переменных в наборе

	finder_coef(f, n, f1, F, xyz, b, k, k1, I);//ищем коэффициенты

	string x;//строка для записи конечной функции
	x = "F=";
	for (int i = 0; i < f; i++)//производим запись вида F=a0+a1x1+a2x2+a3x3
	{
		if (i != 0) x += "+";
		x += to_string(b[i][1]);
		for (int z = 0; z < xyz; z++)
		{
			if (I[i][z] != 0)
				x += "x" + to_string(z + 1);

		}
	}
	ofstream(fout);
	fout.open("file2.txt");//открываем файл для вывода
	fout << "таблица истинности\n";
	for (int i = -1; i < f; i++)//выводим таблицу истинности
	{
		for (int z = 0; z <= xyz; z++)
		{
			if (i != -1) fout << F[i][z] << "\t";
			else {
				if (z == xyz)fout << "F";
				else fout << "x" << (z + 1) << "\t";
			}
		}
		fout << "\n";
	}
	fout << "\n Полином Жегалкина \n" << x;//вывод полинома
	fout.close();
}
int main()
{
	setlocale(LC_ALL, "0");//добавление русского
	int /*x,*/ xyz, f;
	ifstream(fin);
	fin.open("file1.txt");///открытие файла для ввода
	int bl;
	fin >> bl;
	fin >> xyz;//вводим количество переменных
	f = int(pow(2, xyz));//считаем количество коэффициентов
	vector <vector<int>> F(f, vector<int>(xyz + 1));//создание таблицы ситинности
	vector <vector <int>> b(f, vector<int>(2));//создание таблицы решений

	for (int i = 0; i < f; i++)
	{
		for (int j = 0; j < 2; j++)
		{
			b[i][j] = 0;

		}

	}//инициализация^
	if (bl)
	{
		fin.close();
		srand(unsigned(int(time(0))));//задаем условие для рандома
		ofstream(fout);
		fout.open("file1.txt");//открываем тот же файл для вывода
		fout << 1 << ' ';
		fout << xyz << " ";
		for (int i = 0; i < f; i++) //цикл от 0 до до количества 0 и 1
		{
			F[i][xyz] = rand() % 2;
			fout << F[i][xyz] << " ";//рандомим и выводим в файл
		}
		fout.close();//закрывем файл

	}
	else
	{

		for (int i = 0; i < f; i++)
		{
			if (!fin.eof())
				fin >> F[i][xyz];
		}//заполнение занчений функции в доп столбик таблицы истнности
		fin.close();

	}
	schet(f, xyz, F, b);//вызов функции для решения 	
}
//эта программа работает для как минимум 14 переменных при этом в релизе на intel core i7 8650U @1.9Ghz 1:43 мин
//для удобства дополнительно написан рандомайзер

